---
title: "Analysis of transcriptomes. WGCNA tool for W dataset"
author: "Rubén Sancho"
date: "2025-12-16"
output:
  pdf_document: default
  html_document: default
---

```{r setup, include=FALSE}

knitr::opts_chunk$set(echo = TRUE, warning = TRUE, message = TRUE)
```

# Run the chunk only once, removing the hash symbols (#) beforehand.
# It is not necessary to run it again after installation, and it is recommended to add the hash symbols (#) back.

```{r install_WGCNA_v.1.73}

#if (!requireNamespace("BiocManager", quietly = TRUE))
#    install.packages("BiocManager")

#BiocManager::install("GO.db")

#BiocManager::install("impute")

#BiocManager::install("preprocessCore")

#install.packages("WGCNA")

```

# Load WGCNA package

```{r WGCNA}

library(WGCNA)

#help(package = 'WGCNA')
# BiocManager aracını kur (eğer yoksa)
if (!requireNamespace("BiocManager", quietly = TRUE)) install.packages("BiocManager")

# Eksik olan GO.db ve diğer yardımcı paketleri kur
BiocManager::install(c("GO.db", "impute", "preprocessCore"))
```

# Set working directory and load dataset

```{r dataset}

setwd(".")

getwd()

# Water (W)

W_dataset = read.csv("TPM_counts_Drought_W_dataset.csv")
dim(W_dataset)
names(W_dataset)

# Transpose rows/columns in W dataset

datExprW = as.data.frame(t(W_dataset[, -c(1)]));
names(datExprW) = W_dataset$target_id;
rownames(datExprW) = names(W_dataset)[-c(1)];

```

# Filter genes

```{r goodgenes_W}

# Run all chunk

# remove genes with too many missing samples in W


gsgW = goodSamplesGenes(datExprW, verbose = 3);

summary(gsgW)

gsgW$allOK # if TRUE, all genes are ok

if (!gsgW$allOK)
{
  # Optionally, print the gene and sample names that were removed:
  if (sum(!gsgW$goodGenes)>0) 
     printFlush(paste("Removing genes:", paste(names(datExprW)[!gsgW$goodGenes], collapse = ", ")));
  if (sum(!gsgW$goodSamples)>0) 
     printFlush(paste("Removing samples:", paste(rownames(datExprW)[!gsgW$goodSamples], collapse = ", ")));
  datExprW = datExprW[gsgW$goodSamples, gsgW$goodGenes]
  dim(datExprW)
}

```

# Identifying outlier samples.
# You can identify outlier samples by using hierarchical clustering.

```{r w_outliers}

# Run all chunk

# cluster and plot the samples (genes that will come later) to see if there are any obvious outliers

# W dataset outliers detection

sampleTreeW = hclust(dist(datExprW), method = "average")
sizeGrWindow(12,9)
#png("dendrogram_W.png", width = 1600, height = 1200, units = "px", pointsize = 32, bg = "white");
par(cex = 0.6);
par(mar = c(0,4,2,0))
plot(sampleTreeW, main = "W Sample clustering to detect outliers", sub="", xlab="", cex.lab = 1.5, 
     cex.axis = 1.5, cex.main = 2)
outliersW=300000
abline(h=outliersW, col = "red"); # to mark/cut  outliers
#dev.off()

```

# Save filtered dataset

```{r filter_dataset}

## keep only desired samples W dataset

clustW = cutreeStatic(sampleTreeW, cutHeight=outliersW, minSize = 20)
table(clustW)
keepSamplesW = (clustW==1)
datExprW = datExprW[keepSamplesW, ]
nGenesW = ncol(datExprW)
nSamplesW = nrow(datExprW)


## keep filtering dataset

save(datExprW, file = "datExpr_W.RData")

```

# Soft-thresholding powers selection for network construction

```{r W_power}

# Choose a set of soft-thresholding powers

powers = c(c(1:13), seq(from = 14, to=20, by=2))

# Call the network topology analysis function

sftW = pickSoftThreshold(datExprW,
                         powerVector = powers,
                         networkType = "unsigned", # default
                         verbose = 5)
```

```{r Plot_W_power}

# Plot the results:

sizeGrWindow(9, 5)
par(mfrow = c(1,2));
cex1 = 0.9;

# Scale-free topology fit index as a function of the soft-thresholding power W

#png("power_W_pearson_unsigned.png", width = 1600, height = 1200, units = "px", 
#    pointsize = 32, bg = "white");

plot(sftW$fitIndices[,1], -sign(sftW$fitIndices[,3])*sftW$fitIndices[,2],
xlab="Soft Threshold (power)",ylab="Scale Free Topology Model Fit,signed R^2",
type="n",
main = paste("Scale independence (W)"));

text(sftW$fitIndices[,1], -sign(sftW$fitIndices[,3])*sftW$fitIndices[,2],
labels=powers,cex=cex1,col="red");

# this line corresponds to using an R^2 cut-off of h

abline(h=0.85,col="red")
#dev.off()

# Scale-free topology connectivity

#png("connectivity_W_pearson_unsigned.png", width = 1600, height = 1200,
#    units = "px", pointsize = 32, bg = "white");

plot(sftW$fitIndices[,1], sftW$fitIndices[,5],
     xlab="Soft Threshold (power)",ylab="Mean Connectivity", type="n",
     main = paste("Mean connectivity (W)"))
text(sftW$fitIndices[,1], sftW$fitIndices[,5], labels=powers, cex=cex1, 
     col="red")

#dev.off()

```

## Optimal W power = 6


# Unsigned net for D dataset

```{r net_W}

# load dataset

load(file = "datExpr_W.RData");

genes = colnames(datExprW)

# Calling the Adjacency Function

adjacency_W <- adjacency(datExprW, power = 6)

# Topological Overlap Matrix

TOM_W <- TOMsimilarity(adjacency_W)   ## This step takes a long time (5 min) ##

# convert this matrix into a dissimilarity matrix 

TOM_diss_W <- 1-TOM_W

# Hierarchical Clustering Analysis

# Creating the dendrogram 

geneTree_W <- hclust(as.dist(TOM_diss_W), method = "average")

# Plotting the dendrogram

sizeGrWindow(12,9)
plot(geneTree_W, xlab="", sub="", 
     main = "WATER: Gene clustering on TOM-based dissimilarity", 
labels = FALSE, hang = 0.04)

# Identification of modules W

modules_W <- cutreeDynamic(dendro = geneTree_W, distM = TOM_diss_W, 
                           deepSplit = 2, pamRespectsDendro = FALSE, 
                           minClusterSize = 30)


table(modules_W) # returns a table of the counts of factor levels in an object. 
              # In this case how many genes are assigned to each created module


modulecolors_W <- labels2colors(modules_W) # assigns each module number a color

table(modulecolors_W) # returns the counts for each color 
                      # (aka the number of genes within each module)


# Plots the gene dendrogram with the module colors

plotDendroAndColors(geneTree_W, modulecolors_W,"Module W",
dendroLabels = FALSE, hang = 0.03,
addGuide = TRUE, guideHang = 0.05,
main = "Gene dendrogram and module colors for W network")


# Module Eigengene Identification
## A ME (Module Eigengene) is the standardized gene expression profile for 
## a given module.

## An eigengene is the gene whose expression is representative of the the 
## majority of genes expressed within a module.

MElist_W <- moduleEigengenes(datExprW, colors = modulecolors_W) 
MEs_W <- MElist_W$eigengenes 
head(MEs_W)

```

```{r merging}

# Module Merging

ME_diss_W = 1-cor(MElist_W$eigengenes, 
                         use="complete") # Calculate eigengene dissimilarity

METree_W = hclust(as.dist(ME_diss_W), 
                  method = "average") # Clustering eigengenes 
par(mar = c(0,4,2,0)) # setting margin sizes
par(cex = 0.6);# scaling the graphic
plot(METree_W)
abline(h=.25, col = "red") # a height of .25 corresponds to correlation of .75


merge_W <- mergeCloseModules(datExprW, modulecolors_W, cutHeight = .25)


# The merged module colors, assigning one color to each module

mergedcolors_W = merge_W$colors

# Eigengenes of the new merged modules

mergedMEs_W = merge_W$newMEs

# Plot the merged dendrogram

plotDendroAndColors(geneTree_W, cbind(modulecolors_W, mergedcolors_W), 
c("Original Module W", "Merged Module W"),
dendroLabels = FALSE, hang = 0.03,
addGuide = TRUE, guideHang = 0.05,
main = "Dendrogram and modules for original and merged modules in W dataset")

# Rename to modulecolors

modulecolors_W = mergedcolors_W

# Construct numerical labels corresponding to the colors

colororder_W = c("grey", standardColors(50));
 
modulelabels_W = match(modulecolors_W, colororder_W)-1;
 
MEs_W = mergedMEs_W;

table(modulelabels_W) # Merged modules = 36; original modules = 40

table(modulecolors_W)

# Save module colors and labels for use in subsequent parts
 
save(MEs_W, modulelabels_W, modulecolors_W, geneTree_W, file = "net_W.RData")

```
```{r Top_hub_gene}

# Top hub genes for each module:

chooseTopHubInEachModule(
   datExprW, 
   modulecolors_W, 
   omitColors = "grey", 
   power = 6, 
   type = "unsigned")

```
# Export genes-modules

```{r export_modules_genes}

# Export lists of genes within each module of W

load("datExpr_W.RData")
load("net_W.RData")

# Extract gene names

geneNames <- colnames(datExprW)

# Create gene-module table

geneModuleMembership_W <- data.frame(
  Gene = geneNames,
  ModuleColor = modulecolors_W
)

head(geneModuleMembership_W)

# Prepare data frame and export to tsv file

genes_by_module_W <- split(geneModuleMembership_W$Gene, geneModuleMembership_W$ModuleColor)


genes_by_module_df_W <- data.frame(
  ModuleColor = rep(names(genes_by_module_W), times = sapply(genes_by_module_W, length)),
  Gene = unlist(genes_by_module_W, use.names = FALSE)
)

head(genes_by_module_df_W)

# Export to tsv

write.table(genes_by_module_df_W,
            file = "Genes_per_module_W.tsv",
            sep = "\t",        # sep tab
            quote = FALSE,
            row.names = FALSE,
            col.names = TRUE)

```

# Module-trait associations

```{r trait_dataset}

# Load expression data W

load("datExpr_W.RData")

# Load network data W

load("net_W.RData")

# Prepare trait W data set

traitdata <- read.csv("TRAITS_W.csv", header = TRUE, stringsAsFactors = FALSE)

head(traitdata)

# Keep samples and traits

allTraits <- traitdata[, c(4, 6:17) ] # keep samples and traits 
head(allTraits)

# variables/traits numeric

allTraits[, 2:ncol(allTraits)] <- lapply(allTraits[, 2:ncol(allTraits)], 
                                         function(x) as.numeric(as.character(x)))

# check classes

sapply(allTraits, class)

head(allTraits)

# Match the trait data to the expression data by the sample name

Samples <- rownames(datExprW)

traitRows <- match(Samples, allTraits$sample)

datTraits <- allTraits[traitRows, -1]

rownames(datTraits) <- allTraits[traitRows, 1]

# Eigengene gene significance: correlation of the trait with the identified 
# module eigengenes

# Define numbers of genes and samples

nGenes = ncol(datExprW)

nSamples = nrow(datExprW)

module.trait.correlation = cor(MEs_W, 
                               datTraits, 
                               use = "p") # Pearson correlation coefficient

# p-value associated with the correlation

module.trait.Pvalue = corPvalueStudent(module.trait.correlation, nSamples) 

# Will display correlations and their p-values

textMatrix = paste(signif(module.trait.correlation, 2), "\n(",
signif(module.trait.Pvalue, 1), ")", sep = "");

dim(textMatrix) = dim(module.trait.correlation)

pdf("heatmap_traits_modules_W.pdf", width = 8, height = 12) # save in pdf

par(mar = c(6, 8.5, 3, 1))

# Display the correlation values within a heatmap plot

labeledHeatmap(Matrix = module.trait.correlation,
                        xLabels = names(datTraits),
                        yLabels = names(MEs_W),
                        ySymbols = names(MEs_W),
                        colorLabels = FALSE,
                        colors = blueWhiteRed(50),
                        textMatrix = textMatrix,
                        setStdMargins = FALSE,
                        cex.text = 0.4,
                        zlim = c(-1,1),
                        main = paste("Module-trait relationships W"))

dev.off() # save plot in pdf

# The highest +: MEviolet vs  blwgrd (0.66 (p-value = 3e−04))
# The highest - correlation: MEpalevioletred3 vs cn (−0.59 (p-value0.001))

```

